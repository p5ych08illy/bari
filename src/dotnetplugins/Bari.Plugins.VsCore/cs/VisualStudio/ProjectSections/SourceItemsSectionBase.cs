using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Xml;
using Bari.Core.Generic;
using Bari.Core.Model;

namespace Bari.Plugins.VsCore.VisualStudio.ProjectSections
{
    /// <summary>
    /// Base class for MSBuild project file section listing the source files of the project
    /// </summary>
    public abstract class SourceItemsSectionBase : MSBuildProjectSectionBase
    {
        /// <summary>
        /// Initializes the class
        /// </summary>
        /// <param name="suite">Active suite</param>
        protected SourceItemsSectionBase(Suite suite)
            : base(suite)
        {
        }

        /// <summary>
        /// Writes the section using an XML writer
        /// </summary>
        /// <param name="writer">XML writer to use</param>
        /// <param name="project">The project to generate .csproj for</param>
        /// <param name="context">Current .csproj generation context</param>
        public override void Write(XmlWriter writer, Project project, IMSBuildProjectGeneratorContext context)
        {
            writer.WriteStartElement("ItemGroup");

            var orderedFiles = GetOrderedFiles(project);

            foreach (var pair in orderedFiles)
            {
                var file = pair.Item1;
                var sourceSetType = pair.Item2;

                var relativePath = ToProjectRelativePath(project, file, ProjectSourceSetName);
                var logicalPath = GetLogicalPath(project, file, sourceSetType);

                // We have to skip .csproj files, which are generated by bari to the source set because otherwise
                // VisualStudio does not work as expected:
                if (!IgnoredExtensions.Any(ext => relativePath.EndsWith(ext, StringComparison.InvariantCultureIgnoreCase)))
                {
                    WriteItem(writer, project, file, relativePath, sourceSetType, logicalPath);
                }
            }
            writer.WriteEndElement();
        }

        protected virtual void WriteItem(XmlWriter writer, Project project, SuiteRelativePath file, string relativePath, SourceSetType sourceSetType, string logicalPath)
        {
            var elementName = GetElementNameFor(project, file);
            if (!string.IsNullOrEmpty(elementName))
            {
                writer.WriteStartElement(elementName);
                writer.WriteAttributeString("Include", relativePath);

                if (ProjectSourceSetName != sourceSetType)
                    writer.WriteElementString("LogicalName", logicalPath);

                WriteAdditionalOptions(writer, project, file);

                writer.WriteEndElement();
            }
        }

        protected virtual string GetLogicalPath(Project project, SuiteRelativePath file, SourceSetType sourceSetType)
        {
            return ToProjectRelativePath(project, file, sourceSetType);
        }

        private IEnumerable<Tuple<SuiteRelativePath, SourceSetType>> GetOrderedFiles(Project project)
        {
            return from sourceSet in GetSourceSets(project) 
                   from file in OrderSourceFiles(project, sourceSet.Files) 
                   select Tuple.Create(file, sourceSet.Type);
        }

        /// <summary>
        /// Orders the given set of source files if necessary
        /// </summary>
        /// <param name="project">Project being processed</param>
        /// <param name="files">Input sequence</param>
        /// <returns>Output sequence</returns>
        protected virtual IEnumerable<SuiteRelativePath> OrderSourceFiles(Project project, IEnumerable<SuiteRelativePath> files)
        {
            return files;
        }

        /// <summary>
        /// Provides the ability to add extra content to a given project source file
        /// </summary>
        /// <param name="writer">The project file writer</param>
        /// <param name="project">Project model</param>
        /// <param name="suiteRelativePath">Suite relative path of the source item</param>
        protected virtual void WriteAdditionalOptions(XmlWriter writer, Project project, SuiteRelativePath suiteRelativePath)
        {
        }

        /// <summary>
        /// Gets the element name for a given compilation item.
        /// 
        /// <para>The default implementation always returns <c>Compile</c></para>
        /// </summary>
        /// <param name="file">File name from the source set</param>
        /// <returns>Returns a valid XML element name</returns>
        protected virtual string GetElementNameFor(Project project, string file)
        {
            Contract.Requires(file != null);

            return "Compile";
        }

        /// <summary>
        /// Gets the source sets to include 
        /// </summary>
        /// <param name="project">The project to get its source sets</param>
        /// <returns>Returns an enumeration of source sets, all belonging to the given project</returns>
        protected abstract IEnumerable<ISourceSet> GetSourceSets(Project project);

        /// <summary>
        /// Gets a set of filename postfixes to be ignored when generating the source references
        /// </summary>
        protected abstract ISet<string> IgnoredExtensions { get; }

        /// <summary>
        /// Source set name where the project file is placed
        /// </summary>
        protected abstract string ProjectSourceSetName { get; }
    }
}